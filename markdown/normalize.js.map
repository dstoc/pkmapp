{"version":3,"file":"normalize.js","sourceRoot":"","sources":["../../src/markdown/normalize.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {assert} from '../asserts.js';\n\nimport {SectionNode} from './node.js';\nimport {children, dfs} from './view-model-util.js';\nimport {MarkdownTree, ViewModelNode} from './view-model.js';\nimport {cast} from '../asserts.js';\n\nfunction moveTrailingNodesIntoSections(tree: MarkdownTree) {\n  for (const node of dfs(tree.root)) {\n    let section: (SectionNode & ViewModelNode) | undefined;\n    for (const child of children(node)) {\n      if (child.type === 'section') {\n        section = child;\n      } else if (section) {\n        child.viewModel.insertBefore(section);\n      }\n    }\n  }\n}\n\nfunction normalizeContiguousSections(\n  sections: Array<SectionNode & ViewModelNode>\n) {\n  const activeSections: Array<SectionNode & ViewModelNode> = [];\n  function activeSection() {\n    return activeSections[activeSections.length - 1];\n  }\n  for (const section of sections) {\n    if (activeSections.length) {\n      while (\n        section.marker.length < activeSection().marker.length &&\n        activeSections.length > 1\n      ) {\n        activeSections.pop();\n      }\n      if (section.marker.length <= activeSection().marker.length) {\n        if (section.viewModel.previousSibling !== activeSection()) {\n          section.viewModel.insertBefore(\n            activeSection().viewModel.parent!,\n            activeSection().viewModel.nextSibling\n          );\n        }\n        activeSections.pop();\n      } else {\n        assert(section.marker.length > activeSection().marker.length);\n        if (section.viewModel.parent !== activeSection()) {\n          // ensure section is first section child of activeSection\n          let next: ViewModelNode | undefined;\n          for (const child of children(activeSection())) {\n            if (child.type === 'section') {\n              next = child;\n              break;\n            }\n          }\n          section.viewModel.insertBefore(activeSection(), next);\n        }\n      }\n    }\n    activeSections.push(section);\n  }\n}\n\nfunction normalizeSections(tree: MarkdownTree) {\n  moveTrailingNodesIntoSections(tree);\n  type Section = SectionNode & ViewModelNode;\n  const ranges = new Map<Section, Section[]>();\n  for (const node of dfs(tree.root)) {\n    if (node.type !== 'section') continue;\n    const previousSibling = node.viewModel.previousSibling;\n    const parent = node.viewModel.parent;\n    let range: Section[];\n    if (previousSibling?.type === 'section') {\n      range = cast(ranges.get(previousSibling));\n    } else if (parent?.type === 'section') {\n      range = cast(ranges.get(parent));\n    } else {\n      range = [];\n    }\n    range.push(node);\n    ranges.set(node, range);\n  }\n  for (const sections of ranges.values()) {\n    normalizeContiguousSections(sections);\n  }\n}\n\nexport function normalizeTree(tree: MarkdownTree) {\n  const emptyPredicate = (node?: ViewModelNode) =>\n    node &&\n    node.viewModel.parent &&\n    !node.viewModel.firstChild &&\n    ['list-item', 'list', 'block-quote'].includes(node.type);\n  for (const empty of [...dfs(tree.root)].filter(emptyPredicate)) {\n    let node: ViewModelNode | undefined = empty;\n    while (node) {\n      const parent: ViewModelNode | undefined = node.viewModel.parent;\n      node.viewModel.remove();\n      node = emptyPredicate(parent) ? parent : undefined;\n    }\n  }\n  normalizeSections(tree);\n\n  for (const node of dfs(tree.root)) {\n    if (node.type === 'list') {\n      while (node.viewModel.nextSibling?.type === 'list') {\n        const next = node.viewModel.nextSibling;\n        while (next.viewModel.firstChild) {\n          next.viewModel.firstChild.viewModel.insertBefore(node);\n        }\n        next.viewModel.remove();\n      }\n    }\n  }\n  if (!tree.root.viewModel.firstChild) {\n    const child = tree.add({\n      type: 'paragraph',\n      content: '',\n    });\n    child.viewModel.insertBefore(tree.root);\n  }\n}\n"]}