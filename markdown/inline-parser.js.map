{"version":3,"file":"inline-parser.js","sourceRoot":"","sources":["../../src/markdown/inline-parser.ts"],"names":[],"mappings":"AAAA,4BAA4B;AAC5B,EAAE;AACF,kEAAkE;AAClE,mEAAmE;AACnE,0CAA0C;AAC1C,EAAE;AACF,kDAAkD;AAClD,EAAE;AACF,sEAAsE;AACtE,oEAAoE;AACpE,2EAA2E;AAC3E,sEAAsE;AACtE,iCAAiC;AAEjC,OAAO,MAAM,MAAM,wBAAwB,CAAC;AAC5C,OAAO,EAAC,OAAO,EAAC,MAAM,eAAe,CAAC;AAEtC,MAAM,MAAM,CAAC,IAAI,CAAC;IAChB,UAAU,CAAC,IAAY;QACrB,OAAO,OAAO,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC;IACnC,CAAC;CACF,CAAC,CAAC;AACH,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,QAAQ,CAAC,IAAI,CACvC,OAAO,CAAC,yCAAyC,CAAC,CACnD,CAAC;AACF,MAAM,CAAC,MAAM,MAAM,GAAG,IAAI,MAAM,EAAE,CAAC;AACnC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;AAE3B,MAAM,SAAS,CAAC,CAAC,GAAG,CAAC,IAAuB;IAC1C,SAAS,IAAI,CAAC,IAA8B;QAC1C,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;IAC/B,CAAC;IACD,GAAG;QACD,MAAM,IAAI,CAAC;QACX,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;YAAE,SAAS;QACpC,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;YAAE,SAAS;QACrC,GAAG;YACD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;gBAAE,OAAO;SAChC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;KACnC,QAAQ,IAAI,EAAE;AACjB,CAAC","sourcesContent":["// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport Parser from '../deps/tree-sitter.js';\nimport {resolve} from '../resolve.js';\n\nawait Parser.init({\n  locateFile(path: string) {\n    return resolve(`./deps/${path}`);\n  },\n});\nconst inline = await Parser.Language.load(\n  resolve('./deps/tree-sitter-markdown_inline.wasm')\n);\nexport const parser = new Parser();\nparser.setLanguage(inline);\n\nexport function* dfs(node: Parser.SyntaxNode) {\n  function next(next: Parser.SyntaxNode | null) {\n    return next && (node = next);\n  }\n  do {\n    yield node;\n    if (next(node.firstChild)) continue;\n    if (next(node.nextSibling)) continue;\n    do {\n      if (!next(node.parent)) return;\n    } while (!next(node.nextSibling));\n  } while (true);\n}\n"]}